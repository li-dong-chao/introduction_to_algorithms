## 2.2-1

#### 题目

用 $\Theta$ 记号表示函数 $n^3/1000-100n^2-100n+3$ 。

#### 答案

$\Theta(n^3)$

## 2.2-2

#### 题目

考虑排序储存在数组 $A$ 中的 $n$ 个数：首先找出 $A$ 中的最小元素并将其与$A[1]$中的元素进行交换。接着，找出$A$中的次最小元素并将其与$A[2]$中的元素进行交换。对$A$中前$n-1$个元素按该方式继续。该算法称为**选择算法**，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前$n-1$个元素，而不是对所有$n$个元素运行？用$\Theta$记号给出选择排序的最好情况与最快情况运行时间。

#### 答案

- 伪代码：

    ```python
    CHOICE-SORT
    let n = A.length
    for i = 1 to n-1
        cur = i
    	for j = i+1 to n
        	if A[j] < A[cur]:
                cur = j
        tmp = A[cur]
        A[cur] = A[i]
        A[i] = tmp 	
    ```

- 循环不变式为

    对于第$i$次循环，$A[i-1]$是排好序的数组。

- 处理完前$n-1$个元素后，剩下的最后一个元素就是最大的那个元素，因此不需要排序即可。

- 最好情况：数组本身就已经排好了，此时运行时间为$\Theta(n^2)$

- 最坏情况：数组完全逆序，此时运行时间为$\Theta(n^2)$

## 2.2-3

#### 题目

再次考虑线性查找问题（参见练习2.1-3）。假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏的情况又如何呢？用$\Theta$记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

#### 答案

假设要排序的序列为$A$，令$n=A.length$，则平均需要查找的元素个数为$\frac{n+1}{2}$，证明如下：
$$
当第一个元素为目标元素时，这种情况的概率为\frac{1}{n}，此时要查找的元素个数为1；\\
当第一个元素为目标元素时，这种情况的概率为\frac{n-1}{n}\times\frac{1}{n-1} ，此时要查找的元素个数为2；\\
当第一个元素为目标元素时，这种情况的概率为\frac{n-1}{n}\times\frac{n-2}{n-1}\times\frac{1}{n-2}，此时要查找的元素个数为3；\\
依次类推，得平均要查找的元素个数为\\
\frac{1}{n}\times1+\frac{n-1}{n}\times\frac{1}{n-1}\times2+\frac{n-1}{n}\times\frac{n-2}{n-1}\times\frac{1}{n-2}\times3+\dots+\frac{n-1}{n}\times\frac{n-2}{n-1}\times\dots\frac{1}{n-(n-1)}\times n =\\
\frac{1}{n}\times 1+\frac{1}{n}\times 2+\dots+\frac{1}{n}\times n=\frac{n+1}{2}
$$
最坏情况下，整个序列的最后一个元素为要查找的元素，此时需要检查$n$个元素。

平均运行时间为$\Theta(n)$，最坏情况为$\Theta(n)$。

## 2.2-4

#### 题目

我们可以如何修改几乎任意算法来使之具有良好的最好情况运行时间？

#### 答案

在正式算法执行前检查一下数据是否已经处于最优情况，如果已经处于最优情况，则无需处理，直接返回结果即可，可以有效一些算法效率。